"""Comprehensive vulnerability scanner for security audit."""

import asyncio
import aiohttp
import re
import hashlib
import ssl
import socket
import subprocess
import logging
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from enum import Enum
import json
import urllib.parse

from config.security_policies import (
    SecurityPolicies,
    VulnerabilityCategory,
    SecurityLevel,
    security_policies
)


class ScanType(Enum):
    """Types of vulnerability scans."""
    STATIC_ANALYSIS = "static_analysis"
    DYNAMIC_ANALYSIS = "dynamic_analysis"
    INFRASTRUCTURE_SCAN = "infrastructure_scan"
    DEPENDENCY_SCAN = "dependency_scan"
    CONFIGURATION_AUDIT = "configuration_audit"
    OWASP_TOP_10 = "owasp_top_10"
    COMPLIANCE_SCAN = "compliance_scan"


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class Vulnerability:
    """Individual vulnerability finding."""
    vuln_id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    category: VulnerabilityCategory
    cve_id: Optional[str]
    cvss_score: Optional[float]
    affected_component: str
    location: str
    evidence: Dict[str, Any]
    remediation: str
    references: List[str]
    scan_timestamp: datetime
    false_positive: bool = False


@dataclass
class ScanResult:
    """Vulnerability scan result summary."""
    scan_id: str
    scan_type: ScanType
    target: str
    start_time: datetime
    end_time: datetime
    duration_seconds: float
    vulnerabilities: List[Vulnerability]
    summary: Dict[str, int]
    recommendations: List[str]
    compliance_status: Dict[str, bool]


class VulnerabilityPatterns:
    """Vulnerability detection patterns."""

    # SQL Injection Patterns
    SQL_INJECTION_PATTERNS = [
        r"error.*sql",
        r"mysql.*error",
        r"postgresql.*error",
        r"ora-\d{5}",
        r"microsoft.*odbc.*sql",
        r"syntax.*error.*near",
        r"unclosed.*quotation.*mark",
        r"quoted.*string.*not.*properly.*terminated"
    ]

    # XSS Patterns
    XSS_PATTERNS = [
        r"<script[^>]*>.*?</script>",
        r"javascript:",
        r"on\w+\s*=",
        r"<iframe[^>]*>",
        r"document\.cookie",
        r"alert\s*\(",
        r"eval\s*\("
    ]

    # Command Injection Patterns
    COMMAND_INJECTION_PATTERNS = [
        r";\s*(ls|dir|cat|type|ping|wget|curl)",
        r"\|\s*(ls|dir|cat|type|ping|wget|curl)",
        r"&&\s*(ls|dir|cat|type|ping|wget|curl)",
        r"`.*`",
        r"\$\(.*\)"
    ]

    # Information Disclosure Patterns
    INFO_DISCLOSURE_PATTERNS = [
        r"password.*=.*['\"][^'\"]+['\"]",
        r"api[_-]?key.*=.*['\"][^'\"]+['\"]",
        r"secret.*=.*['\"][^'\"]+['\"]",
        r"token.*=.*['\"][^'\"]+['\"]",
        r"(?i)server:\s*(.+)",
        r"(?i)x-powered-by:\s*(.+)",
        r"stack.*trace",
        r"exception.*occurred"
    ]

    # Insecure Configuration Patterns
    INSECURE_CONFIG_PATTERNS = [
        r"(?i)debug\s*=\s*true",
        r"(?i)ssl.*false",
        r"(?i)verify.*false",
        r"(?i)localhost",
        r"(?i)127\.0\.0\.1",
        r"(?i)admin.*admin",
        r"(?i)password.*password"
    ]


class StaticAnalysisScanner:
    """Static code analysis scanner."""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.patterns = VulnerabilityPatterns()

    async def scan_code_directory(self, directory_path: str) -> List[Vulnerability]:
        """Scan code directory for vulnerabilities."""
        vulnerabilities = []

        try:
            # Scan Python files
            python_files = await self._find_files(directory_path, "*.py")
            for file_path in python_files:
                file_vulns = await self._scan_python_file(file_path)
                vulnerabilities.extend(file_vulns)

            # Scan JavaScript files
            js_files = await self._find_files(directory_path, "*.js")
            for file_path in js_files:
                file_vulns = await self._scan_javascript_file(file_path)
                vulnerabilities.extend(file_vulns)

            # Scan configuration files
            config_files = await self._find_files(directory_path, "*.ini", "*.conf", "*.yaml", "*.yml", "*.json")
            for file_path in config_files:
                file_vulns = await self._scan_config_file(file_path)
                vulnerabilities.extend(file_vulns)

        except Exception as e:
            self.logger.error(f"Static analysis error: {str(e)}")

        return vulnerabilities

    async def _find_files(self, directory: str, *patterns: str) -> List[str]:
        """Find files matching patterns."""
        import glob
        import os

        files = []
        for pattern in patterns:
            search_pattern = os.path.join(directory, "**", pattern)
            files.extend(glob.glob(search_pattern, recursive=True))

        return files

    async def _scan_python_file(self, file_path: str) -> List[Vulnerability]:
        """Scan Python file for vulnerabilities."""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Check for SQL injection vulnerabilities
            sql_vulns = self._check_sql_injection_patterns(content, file_path)
            vulnerabilities.extend(sql_vulns)

            # Check for command injection
            cmd_vulns = self._check_command_injection_patterns(content, file_path)
            vulnerabilities.extend(cmd_vulns)

            # Check for hardcoded secrets
            secret_vulns = self._check_hardcoded_secrets(content, file_path)
            vulnerabilities.extend(secret_vulns)

            # Check for insecure configurations
            config_vulns = self._check_insecure_configurations(content, file_path)
            vulnerabilities.extend(config_vulns)

        except Exception as e:
            self.logger.error(f"Error scanning Python file {file_path}: {str(e)}")

        return vulnerabilities

    async def _scan_javascript_file(self, file_path: str) -> List[Vulnerability]:
        """Scan JavaScript file for vulnerabilities."""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Check for XSS vulnerabilities
            xss_vulns = self._check_xss_patterns(content, file_path)
            vulnerabilities.extend(xss_vulns)

            # Check for insecure DOM manipulation
            dom_vulns = self._check_dom_vulnerabilities(content, file_path)
            vulnerabilities.extend(dom_vulns)

        except Exception as e:
            self.logger.error(f"Error scanning JavaScript file {file_path}: {str(e)}")

        return vulnerabilities

    async def _scan_config_file(self, file_path: str) -> List[Vulnerability]:
        """Scan configuration file for vulnerabilities."""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Check for exposed secrets
            secret_vulns = self._check_exposed_secrets_in_config(content, file_path)
            vulnerabilities.extend(secret_vulns)

            # Check for insecure settings
            setting_vulns = self._check_insecure_settings(content, file_path)
            vulnerabilities.extend(setting_vulns)

        except Exception as e:
            self.logger.error(f"Error scanning config file {file_path}: {str(e)}")

        return vulnerabilities

    def _check_sql_injection_patterns(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for SQL injection patterns."""
        vulnerabilities = []

        # Look for string concatenation in SQL queries
        sql_concat_patterns = [
            r"['\"].*\+.*['\"].*SELECT",
            r"['\"].*%.*['\"].*SELECT",
            r"['\"].*\.format\(.*\).*SELECT",
            r"['\"].*f['\"].*SELECT"
        ]

        for pattern in sql_concat_patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                line_num = content[:match.start()].count('\n') + 1
                vuln = Vulnerability(
                    vuln_id=f"SQL_INJ_{hashlib.md5(f'{file_path}_{line_num}'.encode()).hexdigest()[:8]}",
                    title="Potential SQL Injection",
                    description="SQL query appears to use string concatenation which may lead to SQL injection",
                    severity=VulnerabilitySeverity.HIGH,
                    category=VulnerabilityCategory.INJECTION,
                    cve_id=None,
                    cvss_score=8.1,
                    affected_component=file_path,
                    location=f"Line {line_num}",
                    evidence={"pattern": pattern, "match": match.group()},
                    remediation="Use parameterized queries or prepared statements",
                    references=["https://owasp.org/www-community/attacks/SQL_Injection"],
                    scan_timestamp=datetime.now()
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _check_command_injection_patterns(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for command injection patterns."""
        vulnerabilities = []

        # Look for potentially dangerous function calls
        dangerous_functions = [
            r"os\.system\(",
            r"subprocess\.call\(",
            r"subprocess\.run\(",
            r"eval\(",
            r"exec\("
        ]

        for pattern in dangerous_functions:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                line_num = content[:match.start()].count('\n') + 1
                vuln = Vulnerability(
                    vuln_id=f"CMD_INJ_{hashlib.md5(f'{file_path}_{line_num}'.encode()).hexdigest()[:8]}",
                    title="Potential Command Injection",
                    description="Use of potentially dangerous function that could lead to command injection",
                    severity=VulnerabilitySeverity.HIGH,
                    category=VulnerabilityCategory.INJECTION,
                    cve_id=None,
                    cvss_score=7.5,
                    affected_component=file_path,
                    location=f"Line {line_num}",
                    evidence={"function": match.group(), "line": line_num},
                    remediation="Validate input and use safe alternatives",
                    references=["https://owasp.org/www-community/attacks/Command_Injection"],
                    scan_timestamp=datetime.now()
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _check_hardcoded_secrets(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for hardcoded secrets."""
        vulnerabilities = []

        for pattern in self.patterns.INFO_DISCLOSURE_PATTERNS:
            matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                line_num = content[:match.start()].count('\n') + 1
                vuln = Vulnerability(
                    vuln_id=f"SECRET_{hashlib.md5(f'{file_path}_{line_num}'.encode()).hexdigest()[:8]}",
                    title="Hardcoded Secret",
                    description="Potential hardcoded secret or sensitive information",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category=VulnerabilityCategory.CRYPTOGRAPHY,
                    cve_id=None,
                    cvss_score=6.5,
                    affected_component=file_path,
                    location=f"Line {line_num}",
                    evidence={"pattern": pattern, "match": match.group()},
                    remediation="Use environment variables or secure key management",
                    references=["https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password"],
                    scan_timestamp=datetime.now()
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _check_insecure_configurations(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for insecure configurations."""
        vulnerabilities = []

        for pattern in self.patterns.INSECURE_CONFIG_PATTERNS:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                line_num = content[:match.start()].count('\n') + 1
                vuln = Vulnerability(
                    vuln_id=f"CONFIG_{hashlib.md5(f'{file_path}_{line_num}'.encode()).hexdigest()[:8]}",
                    title="Insecure Configuration",
                    description="Potentially insecure configuration setting detected",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category=VulnerabilityCategory.CONFIGURATION,
                    cve_id=None,
                    cvss_score=5.0,
                    affected_component=file_path,
                    location=f"Line {line_num}",
                    evidence={"setting": match.group()},
                    remediation="Review and secure configuration settings",
                    references=["https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration"],
                    scan_timestamp=datetime.now()
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _check_xss_patterns(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for XSS patterns in JavaScript."""
        vulnerabilities = []

        for pattern in self.patterns.XSS_PATTERNS:
            matches = re.finditer(pattern, content, re.IGNORECASE | re.DOTALL)
            for match in matches:
                line_num = content[:match.start()].count('\n') + 1
                vuln = Vulnerability(
                    vuln_id=f"XSS_{hashlib.md5(f'{file_path}_{line_num}'.encode()).hexdigest()[:8]}",
                    title="Potential XSS Vulnerability",
                    description="Potential cross-site scripting vulnerability detected",
                    severity=VulnerabilitySeverity.HIGH,
                    category=VulnerabilityCategory.INJECTION,
                    cve_id=None,
                    cvss_score=7.3,
                    affected_component=file_path,
                    location=f"Line {line_num}",
                    evidence={"pattern": pattern, "match": match.group()},
                    remediation="Sanitize user input and use Content Security Policy",
                    references=["https://owasp.org/www-community/attacks/xss/"],
                    scan_timestamp=datetime.now()
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _check_dom_vulnerabilities(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for DOM-based vulnerabilities."""
        vulnerabilities = []

        dom_sink_patterns = [
            r"innerHTML\s*=",
            r"outerHTML\s*=",
            r"document\.write\s*\(",
            r"location\.href\s*=",
            r"window\.location\s*="
        ]

        for pattern in dom_sink_patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                line_num = content[:match.start()].count('\n') + 1
                vuln = Vulnerability(
                    vuln_id=f"DOM_{hashlib.md5(f'{file_path}_{line_num}'.encode()).hexdigest()[:8]}",
                    title="DOM-based Vulnerability",
                    description="Potential DOM-based vulnerability detected",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category=VulnerabilityCategory.INJECTION,
                    cve_id=None,
                    cvss_score=6.1,
                    affected_component=file_path,
                    location=f"Line {line_num}",
                    evidence={"sink": match.group()},
                    remediation="Validate and sanitize all DOM operations",
                    references=["https://owasp.org/www-community/attacks/DOM_Based_XSS"],
                    scan_timestamp=datetime.now()
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _check_exposed_secrets_in_config(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for exposed secrets in configuration files."""
        vulnerabilities = []

        secret_patterns = [
            r"password\s*[:=]\s*['\"]?[^'\"\\s]+['\"]?",
            r"secret\s*[:=]\s*['\"]?[^'\"\\s]+['\"]?",
            r"key\s*[:=]\s*['\"]?[^'\"\\s]+['\"]?",
            r"token\s*[:=]\s*['\"]?[^'\"\\s]+['\"]?"
        ]

        for pattern in secret_patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                line_num = content[:match.start()].count('\n') + 1
                vuln = Vulnerability(
                    vuln_id=f"EXPOSED_{hashlib.md5(f'{file_path}_{line_num}'.encode()).hexdigest()[:8]}",
                    title="Exposed Secret in Configuration",
                    description="Potential secret exposed in configuration file",
                    severity=VulnerabilitySeverity.HIGH,
                    category=VulnerabilityCategory.DATA_EXPOSURE,
                    cve_id=None,
                    cvss_score=7.5,
                    affected_component=file_path,
                    location=f"Line {line_num}",
                    evidence={"match": match.group()},
                    remediation="Move secrets to environment variables or secure vault",
                    references=["https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password"],
                    scan_timestamp=datetime.now()
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _check_insecure_settings(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for insecure settings in configuration files."""
        vulnerabilities = []

        insecure_settings = [
            r"debug\s*[:=]\s*true",
            r"ssl_verify\s*[:=]\s*false",
            r"verify_ssl\s*[:=]\s*false",
            r"check_hostname\s*[:=]\s*false"
        ]

        for pattern in insecure_settings:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                line_num = content[:match.start()].count('\n') + 1
                vuln = Vulnerability(
                    vuln_id=f"SETTING_{hashlib.md5(f'{file_path}_{line_num}'.encode()).hexdigest()[:8]}",
                    title="Insecure Configuration Setting",
                    description="Insecure configuration setting detected",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category=VulnerabilityCategory.CONFIGURATION,
                    cve_id=None,
                    cvss_score=5.3,
                    affected_component=file_path,
                    location=f"Line {line_num}",
                    evidence={"setting": match.group()},
                    remediation="Review and secure configuration settings",
                    references=["https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration"],
                    scan_timestamp=datetime.now()
                )
                vulnerabilities.append(vuln)

        return vulnerabilities


class DynamicAnalysisScanner:
    """Dynamic application security testing scanner."""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.logger = logging.getLogger(__name__)

    async def scan_web_application(self) -> List[Vulnerability]:
        """Scan web application for vulnerabilities."""
        vulnerabilities = []

        try:
            # Test authentication
            auth_vulns = await self._test_authentication_vulnerabilities()
            vulnerabilities.extend(auth_vulns)

            # Test input validation
            input_vulns = await self._test_input_validation()
            vulnerabilities.extend(input_vulns)

            # Test session management
            session_vulns = await self._test_session_management()
            vulnerabilities.extend(session_vulns)

            # Test security headers
            header_vulns = await self._test_security_headers()
            vulnerabilities.extend(header_vulns)

        except Exception as e:
            self.logger.error(f"Dynamic analysis error: {str(e)}")

        return vulnerabilities

    async def _test_authentication_vulnerabilities(self) -> List[Vulnerability]:
        """Test for authentication vulnerabilities."""
        vulnerabilities = []

        try:
            async with aiohttp.ClientSession() as session:
                # Test for default credentials
                default_creds = [
                    ("admin", "admin"),
                    ("admin", "password"),
                    ("test", "test")
                ]

                for username, password in default_creds:
                    login_data = {"username": username, "password": password}
                    async with session.post(f"{self.base_url}/api/auth/login", json=login_data) as response:
                        if response.status == 200:
                            vuln = Vulnerability(
                                vuln_id=f"AUTH_DEFAULT_{username}",
                                title="Default Credentials",
                                description=f"Default credentials accepted: {username}/{password}",
                                severity=VulnerabilitySeverity.CRITICAL,
                                category=VulnerabilityCategory.AUTHENTICATION,
                                cve_id=None,
                                cvss_score=9.8,
                                affected_component="/api/auth/login",
                                location="Authentication endpoint",
                                evidence={"username": username, "status": response.status},
                                remediation="Change default credentials and enforce strong password policy",
                                references=["https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication"],
                                scan_timestamp=datetime.now()
                            )
                            vulnerabilities.append(vuln)

        except Exception as e:
            self.logger.error(f"Authentication test error: {str(e)}")

        return vulnerabilities

    async def _test_input_validation(self) -> List[Vulnerability]:
        """Test for input validation vulnerabilities."""
        vulnerabilities = []

        # SQL injection payloads
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --"
        ]

        # XSS payloads
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>"
        ]

        try:
            async with aiohttp.ClientSession() as session:
                # Test SQL injection
                for payload in sql_payloads:
                    test_url = f"{self.base_url}/api/property/search?address={urllib.parse.quote(payload)}"
                    async with session.get(test_url) as response:
                        content = await response.text()
                        if any(pattern in content.lower() for pattern in ["error", "mysql", "sql", "syntax"]):
                            vuln = Vulnerability(
                                vuln_id=f"SQLI_{hashlib.md5(payload.encode()).hexdigest()[:8]}",
                                title="SQL Injection Vulnerability",
                                description="Application appears vulnerable to SQL injection",
                                severity=VulnerabilitySeverity.CRITICAL,
                                category=VulnerabilityCategory.INJECTION,
                                cve_id=None,
                                cvss_score=9.3,
                                affected_component="/api/property/search",
                                location="address parameter",
                                evidence={"payload": payload, "response": content[:200]},
                                remediation="Use parameterized queries and input validation",
                                references=["https://owasp.org/www-community/attacks/SQL_Injection"],
                                scan_timestamp=datetime.now()
                            )
                            vulnerabilities.append(vuln)

                # Test XSS
                for payload in xss_payloads:
                    test_data = {"message": payload, "session_id": "test"}
                    async with session.post(f"{self.base_url}/api/chat/message", json=test_data) as response:
                        content = await response.text()
                        if payload in content and "text/html" in response.headers.get("content-type", ""):
                            vuln = Vulnerability(
                                vuln_id=f"XSS_{hashlib.md5(payload.encode()).hexdigest()[:8]}",
                                title="Cross-Site Scripting (XSS)",
                                description="Application appears vulnerable to XSS attacks",
                                severity=VulnerabilitySeverity.HIGH,
                                category=VulnerabilityCategory.INJECTION,
                                cve_id=None,
                                cvss_score=7.3,
                                affected_component="/api/chat/message",
                                location="message parameter",
                                evidence={"payload": payload, "reflected": True},
                                remediation="Implement input validation and output encoding",
                                references=["https://owasp.org/www-community/attacks/xss/"],
                                scan_timestamp=datetime.now()
                            )
                            vulnerabilities.append(vuln)

        except Exception as e:
            self.logger.error(f"Input validation test error: {str(e)}")

        return vulnerabilities

    async def _test_session_management(self) -> List[Vulnerability]:
        """Test for session management vulnerabilities."""
        vulnerabilities = []

        try:
            async with aiohttp.ClientSession() as session:
                # Test session fixation
                async with session.get(f"{self.base_url}/api/health") as response:
                    session_cookie = response.cookies.get("session_id")
                    if session_cookie and not session_cookie.get("secure"):
                        vuln = Vulnerability(
                            vuln_id="SESSION_INSECURE",
                            title="Insecure Session Cookie",
                            description="Session cookie missing Secure flag",
                            severity=VulnerabilitySeverity.MEDIUM,
                            category=VulnerabilityCategory.SESSION_MANAGEMENT,
                            cve_id=None,
                            cvss_score=6.1,
                            affected_component="Session Management",
                            location="Cookie attributes",
                            evidence={"cookie_name": "session_id", "secure_flag": False},
                            remediation="Set Secure flag on session cookies",
                            references=["https://owasp.org/www-community/controls/SecureCookieAttribute"],
                            scan_timestamp=datetime.now()
                        )
                        vulnerabilities.append(vuln)

        except Exception as e:
            self.logger.error(f"Session management test error: {str(e)}")

        return vulnerabilities

    async def _test_security_headers(self) -> List[Vulnerability]:
        """Test for missing security headers."""
        vulnerabilities = []

        required_headers = {
            "X-Frame-Options": "Missing clickjacking protection",
            "X-Content-Type-Options": "Missing MIME type sniffing protection",
            "X-XSS-Protection": "Missing XSS protection header",
            "Strict-Transport-Security": "Missing HTTPS enforcement",
            "Content-Security-Policy": "Missing CSP header"
        }

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{self.base_url}/") as response:
                    for header, description in required_headers.items():
                        if header not in response.headers:
                            vuln = Vulnerability(
                                vuln_id=f"HEADER_{header.replace('-', '_')}",
                                title=f"Missing Security Header: {header}",
                                description=description,
                                severity=VulnerabilitySeverity.MEDIUM,
                                category=VulnerabilityCategory.CONFIGURATION,
                                cve_id=None,
                                cvss_score=5.3,
                                affected_component="HTTP Headers",
                                location="Response headers",
                                evidence={"missing_header": header},
                                remediation=f"Add {header} security header",
                                references=["https://owasp.org/www-project-secure-headers/"],
                                scan_timestamp=datetime.now()
                            )
                            vulnerabilities.append(vuln)

        except Exception as e:
            self.logger.error(f"Security headers test error: {str(e)}")

        return vulnerabilities


class VulnerabilityScanner:
    """Main vulnerability scanner orchestrator."""

    def __init__(self, base_url: str = "http://localhost:8000", code_directory: str = "."):
        self.base_url = base_url
        self.code_directory = code_directory
        self.logger = logging.getLogger(__name__)
        self.static_scanner = StaticAnalysisScanner()
        self.dynamic_scanner = DynamicAnalysisScanner(base_url)

    async def run_comprehensive_scan(self) -> ScanResult:
        """Run comprehensive vulnerability scan."""
        scan_id = f"vuln_scan_{int(datetime.now().timestamp())}"
        start_time = datetime.now()

        self.logger.info(f"Starting comprehensive vulnerability scan {scan_id}")

        all_vulnerabilities = []

        try:
            # Static analysis
            self.logger.info("Running static code analysis...")
            static_vulns = await self.static_scanner.scan_code_directory(self.code_directory)
            all_vulnerabilities.extend(static_vulns)

            # Dynamic analysis
            self.logger.info("Running dynamic application testing...")
            dynamic_vulns = await self.dynamic_scanner.scan_web_application()
            all_vulnerabilities.extend(dynamic_vulns)

        except Exception as e:
            self.logger.error(f"Scan error: {str(e)}")

        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()

        # Generate summary
        summary = self._generate_vulnerability_summary(all_vulnerabilities)

        # Generate recommendations
        recommendations = self._generate_security_recommendations(all_vulnerabilities)

        # Check compliance
        compliance_status = self._check_compliance_status(all_vulnerabilities)

        result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.OWASP_TOP_10,
            target=f"{self.base_url} + {self.code_directory}",
            start_time=start_time,
            end_time=end_time,
            duration_seconds=duration,
            vulnerabilities=all_vulnerabilities,
            summary=summary,
            recommendations=recommendations,
            compliance_status=compliance_status
        )

        self.logger.info(f"Vulnerability scan completed: {len(all_vulnerabilities)} vulnerabilities found")
        return result

    def _generate_vulnerability_summary(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Generate vulnerability summary by severity and category."""
        summary = {
            "total": len(vulnerabilities),
            "critical": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]),
            "high": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]),
            "medium": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM]),
            "low": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.LOW]),
            "info": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.INFO])
        }

        # Add category breakdown
        for category in VulnerabilityCategory:
            count = len([v for v in vulnerabilities if v.category == category])
            summary[f"category_{category.value}"] = count

        return summary

    def _generate_security_recommendations(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Generate security recommendations based on findings."""
        recommendations = []

        critical_count = len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL])
        high_count = len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH])

        if critical_count > 0:
            recommendations.append(f"URGENT: Address {critical_count} critical vulnerabilities immediately")

        if high_count > 0:
            recommendations.append(f"HIGH PRIORITY: Address {high_count} high-severity vulnerabilities")

        # Category-specific recommendations
        categories = set(v.category for v in vulnerabilities)
        if VulnerabilityCategory.INJECTION in categories:
            recommendations.append("Implement comprehensive input validation and parameterized queries")

        if VulnerabilityCategory.AUTHENTICATION in categories:
            recommendations.append("Strengthen authentication mechanisms and implement MFA")

        if VulnerabilityCategory.CRYPTOGRAPHY in categories:
            recommendations.append("Review and improve cryptographic implementations")

        if VulnerabilityCategory.CONFIGURATION in categories:
            recommendations.append("Harden system and application configurations")

        if not vulnerabilities:
            recommendations.append("No vulnerabilities detected - maintain current security posture")

        return recommendations

    def _check_compliance_status(self, vulnerabilities: List[Vulnerability]) -> Dict[str, bool]:
        """Check compliance status based on vulnerabilities."""
        compliance_status = {}

        # OWASP Top 10 compliance
        owasp_categories = [v.category for v in vulnerabilities if v.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]]
        compliance_status["owasp_top_10"] = len(owasp_categories) == 0

        # SOC 2 compliance
        soc2_violations = [v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]
        compliance_status["soc2_type_ii"] = len(soc2_violations) == 0

        # NIST CSF compliance
        security_violations = [v for v in vulnerabilities if v.category in [
            VulnerabilityCategory.AUTHENTICATION,
            VulnerabilityCategory.AUTHORIZATION,
            VulnerabilityCategory.CRYPTOGRAPHY
        ]]
        compliance_status["nist_csf"] = len(security_violations) == 0

        return compliance_status

    def export_scan_results(self, scan_result: ScanResult, format_type: str = "json") -> str:
        """Export scan results in specified format."""
        if format_type.lower() == "json":
            return json.dumps(asdict(scan_result), default=str, indent=2)
        else:
            raise ValueError(f"Unsupported export format: {format_type}")


# Example usage and testing
if __name__ == "__main__":
    async def run_vulnerability_scan():
        scanner = VulnerabilityScanner("http://localhost:8000", "/home/glitch/Projects/Active/centuryproptax")

        print("Starting comprehensive vulnerability scan...")
        result = await scanner.run_comprehensive_scan()

        print(f"\nScan Results Summary:")
        print(f"  Scan ID: {result.scan_id}")
        print(f"  Duration: {result.duration_seconds:.1f} seconds")
        print(f"  Total vulnerabilities: {result.summary['total']}")
        print(f"  Critical: {result.summary['critical']}")
        print(f"  High: {result.summary['high']}")
        print(f"  Medium: {result.summary['medium']}")
        print(f"  Low: {result.summary['low']}")

        print(f"\nCompliance Status:")
        for framework, status in result.compliance_status.items():
            status_text = "PASS" if status else "FAIL"
            print(f"  {framework.upper()}: {status_text}")

        print(f"\nTop Recommendations:")
        for i, rec in enumerate(result.recommendations[:3], 1):
            print(f"  {i}. {rec}")

        if result.vulnerabilities:
            print(f"\nTop Vulnerabilities:")
            critical_vulns = [v for v in result.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]
            for vuln in critical_vulns[:3]:
                print(f"  - {vuln.title} ({vuln.affected_component})")

    # Run example
    asyncio.run(run_vulnerability_scan())